import itertools
import Harmonic_Graph_Constructors.harmonic_web
from pythonosc import osc_message_builder
from Utility_Tools.mapping_functions import linear_to_logistic as l2l
from Classes.chord import Chord
from pythonosc.udp_client import SimpleUDPClient
from typing import Union


def generate_pitch_materials(web: Harmonic_Graph_Constructors.harmonic_web.HarmonicWeb, octave: int,
                             current_chord: Chord):
    """
    This helper function simply returns an array of midi note numbers according to the input chord.
    :param web: HarmonicWeb
    :param octave: int
    :param current_chord: Chord
    :return: list of lists
    """
    chords = [current_chord]
    for chord in web.web[current_chord]:
        chords.append(chord)
    return [[note.midi_note_number + 12 * octave for note in chord.notes] for chord in chords]


def send_chord_materials(notes: list, client: SimpleUDPClient, time_interval: Union[float, int],
                         harmonic_rhythm: Union[float, int]):
    """
    Builds pitch materials into an OSC message, send to SuperCollider.
    :param harmonic_rhythm: float || int
    :param time_interval: float || int
    :param notes: List of lists of Notes generated by generate_pitch_materials helper function.
    :param client: SimpleUDPClient
    :return: None
    """
    msg = osc_message_builder.OscMessageBuilder(address='/harmonic_materials')
    pitches = list(itertools.chain(*[note for chord in notes for note in chord]))
    msg.add_arg(harmonic_rhythm, arg_type='f')
    msg.add_arg(time_interval, arg_type='f')
    for pitch in pitches:
        msg.add_arg(pitch, arg_type='i')
    msg = msg.build()
    client.send(msg)


def random_walk_only_new(num_chords_walked: int, harmonic_web: Harmonic_Graph_Constructors.harmonic_web.HarmonicWeb,
                         client: SimpleUDPClient, octave: Union[int, None] = None,
                         time_interval: Union[float, int, None] = None,
                         harmonic_rhythm: Union[float, int, None] = None):
    """
    Function that walks randomly through a harmonic web object, selects
    Chord objects that have not been visited yet and sends their pitch materials to SC.
    :param client: SimpleUDPClient
    :param harmonic_rhythm: float || int || None
    :param num_chords_walked: int
    :param harmonic_web: HarmonicWeb
    :param octave: int || None
    :param time_interval: float || int || None.
    :return: None
    """
    if octave is None:
        octave = 5

    if time_interval is None:
        time_interval = 5

    if harmonic_rhythm is None:
        harmonic_rhythm = 5

    chords = harmonic_web.random_walk_only_new(num_chords_walked)
    schedule_chords(chords, time_interval, harmonic_rhythm, harmonic_web, octave, client)


def schedule_chords(chords: list, time_interval: Union[float, int], harmonic_rhythm: Union[float, int],
                    chord_graph: Harmonic_Graph_Constructors.harmonic_web.HarmonicWeb, octave: int,
                    client: SimpleUDPClient):
    """
    A helper function that schedules the chords passed in and sends them over to SuperCollider
    :param chords: list of Chords
    :param time_interval: float || int
    :param harmonic_rhythm: float || int
    :param chord_graph: HarmonicWeb
    :param octave: int
    :param client: SimpleUDPClient
    :return: None
    """
    pitch_materials = []
    for chord in chords:
        pitch_materials.append(generate_pitch_materials(chord_graph, octave, chord))
    send_chord_materials(pitch_materials, client, time_interval, harmonic_rhythm)


def num_chords_walked(lev_mean: float, lev_standard_of_deviation: float):
    """
    Helper function for building the number of chords walked by mapping the Levenshtein mean using a logistic algorithm.
    :param lev_mean: flaot
    :param lev_standard_of_deviation: float
    :return: int
    """
    return int(l2l(abs(lev_mean), 0, 100, 0, 10, lev_standard_of_deviation))
